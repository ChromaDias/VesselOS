# Shared Ledger and Bloom Chain Adapter

This document explains how the Echo Garden shared JSON ledger (agents/state.py) works and how it integrates with the Bloom Chain adapter (agents/bloom_chain.py) to provide an append‑only, tamper‑evident history.

## Ledger: JSON State Store

- Single source of truth: `artifacts/state.json` stores all agent records.
- Categories (top‑level keys): `glyphs`, `glyph_analysis`, `mrp_embeds`, `mrp_extracts`, `lsb_covers`, `lsb_embeds`, `lsb_extracts`.
- Record IDs: human‑readable keys per category, generated by the store.
- Thread‑safe: a re‑entrant lock guards mutations.
- Durable writes: atomic file replace prevents partial writes.

Example layout
```json
{
  "glyphs": {
    "glyphs_0001": {"token":"I-Glyph","size":32,"file":"artifacts/glyphs/glyph_1.npy","created":"2025-10-24T10:00:00Z"}
  },
  "glyph_analysis": {
    "glyph_analysis_0001": {"source":"glyphs_0001","mse":0.0023,"fft_mean":0.1234,"created":"2025-10-24T10:00:05Z"}
  },
  "mrp_embeds": {
    "mrp_embeds_0001": {"cover":"assets/images/cover.png","output":"artifacts/mrp/stego_1.png","message":"Hello, Garden.","metadata":{"glyph_ref":"glyphs_0001"},"created":"2025-10-24T10:00:10Z"}
  }
}
```

API reference
- Create: `JsonStateStore.create_record(section, payload, record_id=None) -> str`
- Read: `get_record(section, record_id) -> dict`
- List: `list_section(section) -> dict[str, dict]`
- Patch/Update: `patch_record(...)`, `update_record(...)`
- Persist: `flush()`

File references
- Echo-Community-Toolkit/agents/state.py:1 — implementation

## Bloom Chain: Append‑Only Audit Log

- Purpose: mirror each ledger creation into an append‑only hash chain, stored at `artifacts/chain.log` (JSONL).
- Block fields: `index`, `prev_hash`, `hash`, and `payload{type, record_id, data, timestamp}`.
- Hashing: SHA‑256 over `index|prev_hash|json(payload)` with stable key ordering.
- Start: first block uses `prev_hash = "GENESIS"`.

File references
- Echo-Community-Toolkit/agents/bloom_chain.py:1 — adapter class

## Wiring: Auto‑commit to Chain and Back‑reference

- The state store accepts an `on_create` callback.
- Agents pass `BloomChainAdapter.record_event` to the store; the returned block hash is recorded on the entry as `block_hash`.

Example (already wired in agents)
- Echo-Community-Toolkit/agents/glyph_agent.py:124 — create adapter and store
- Echo-Community-Toolkit/agents/glyph_agent.py:125 — `JsonStateStore(..., on_create=adapter.record_event)`
- Same wiring is used in `mrp_agent.py` and `lsb_agent.py`.

## Concurrency and Durability

- In‑process safety: RLock guards mutations.
- Atomic writes: JSON is written to a temp file and `os.replace`d into place to avoid torn writes.
- Append‑only chain: blocks are appended one per line; never rewritten.

## Migration‑Ready

- The store is the abstraction boundary. Replacing JSON with a DB or external ledger can be done by swapping internals while retaining the interface.
- The chain adapter can later broadcast blocks to peers for consensus; today it offers local tamper‑evidence and easy audits.

## Tips

- Use `sections()` and `snapshot()` for quick diagnostics.
- Keep `artifacts/` under source control ignore; check in small, illustrative snapshots if desired, not live state.
- When adding new categories, use consistent ID prefixes and reference related IDs for clear lineage (e.g., `glyph_ref`).

